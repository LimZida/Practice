####서비스와 서비스간 의존이 좋은가?

A 서비스와 B 서비스를 서로 연결해서 사용하는 것과, 컨트롤러에서 A 서비스와 B 서비스를 따로 사용하는 것은 상황에 따라 다를 수 있습니다. 각 접근 방식에는 장단점이 있으므로, 적절한 방법을 선택해야 합니다.

A 서비스와 B 서비스를 서로 연결해서 사용하는 방식:
이 접근 방식은 A 서비스와 B 서비스 간의 결합도가 높아지는 경향이 있습니다. A 서비스에서 B 서비스를 직접 참조하고 사용하기 때문에, A 서비스의 코드가 B 서비스에 종속될 수 있습니다. 이로 인해 유연성이 감소할 수 있으며, 코드의 수정이 더 어려울 수 있습니다. 또한, B 서비스의 변경이 A 서비스에 영향을 줄 수 있습니다.
이 방식은 주로 A와 B 서비스가 강하게 연관되어 있고, B 서비스의 기능을 A 서비스가 필수적으로 사용해야 할 때 유용합니다. 예를 들어, A 서비스가 데이터베이스에 접근해야 하는데, B 서비스가 데이터베이스 연결을 담당한다면, A 서비스는 B 서비스를 사용해야만 데이터베이스에 접근할 수 있을 것입니다.

컨트롤러에서 A 서비스와 B 서비스를 따로 사용하는 방식:
이 접근 방식은 A 서비스와 B 서비스 간의 결합도를 낮출 수 있습니다. 컨트롤러에서는 각 서비스를 독립적으로 사용하며, 서비스 간의 상호작용은 컨트롤러에서 조정합니다. 이렇게 하면 각 서비스는 독립적으로 변경 및 테스트할 수 있고, 유연성과 모듈성이 향상됩니다. 또한, 특정 서비스에 의존하는 컨트롤러의 동작을 쉽게 변경할 수 있습니다.
이 방식은 A와 B 서비스가 서로 독립적으로 동작할 수 있는 경우나, A와 B 서비스 간의 상호작용이 복잡하지 않은 경우에 유용합니다. 예를 들어, A 서비스는 외부 API를 호출하고, B 서비스는 데이터베이스에 접근한다고 가정해봅시다. 컨트롤러에서는 A 서비스와 B 서비스를 따로 호출하여 필요한 데이터를 조합하거나 처리할 수 있습니다.

따라서, 선택하는 방법은 상황과 요구사항에 따라 달라집니다. 서비스 간의 결합도를 고려하고, 유연성과 모듈성을 최대한 확보하는 방식을 선택하는 것이 좋습니다.

참고:
https://jangjjolkit.tistory.com/62
https://taesan94.tistory.com/268
https://www.inflearn.com/questions/111740/%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%88%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A5%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%98%B8%EC%B6%9C%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC


####DTO의 역할이 어떻게되는가?

스프링에서 DTO(Data Transfer Object)는 데이터를 전송하거나 전달하기 위한 객체로 사용됩니다. DTO는 비즈니스 로직을 가지지 않고 순수히 데이터를 저장하고 전달하는 역할을 수행합니다. 이러한 특성 때문에 DTO는 주로 다음과 같은 상황에서 사용됩니다:

데이터 전송: 클라이언트와 서버 간에 데이터를 전송할 때 DTO를 사용합니다. 예를 들어, HTTP 요청 및 응답에서 데이터를 전달하거나 원격 API 호출에서 인자로 전달하는 경우 DTO를 활용할 수 있습니다.
뷰 모델: MVC 아키텍처에서 뷰와 컨트롤러 사이에서 데이터를 전달하기 위해 DTO를 사용할 수 있습니다. 컨트롤러는 비즈니스 로직을 처리하고 결과를 DTO에 담아 뷰로 전달합니다.
데이터 매핑: 여러 개의 엔티티나 데이터 소스에서 가져온 데이터를 한 번에 전송하거나 다른 형태로 변환할 때 DTO를 사용합니다. 이를 통해 데이터베이스 쿼리 결과를 객체로 매핑하거나 다양한 소스로부터 가져온 데이터를 일관성 있게 처리할 수 있습니다.

DTO를 사용할 때 몇 가지 가이드라인을 따를 수 있습니다-
필요한 데이터만 포함: DTO는 필요한 데이터만 포함하도록 설계되어야 합니다. 불필요한 데이터를 포함하면 네트워크 대역폭이 낭비되고, 직렬화 및 역직렬화 과정에서 성능 저하가 발생할 수 있습니다.
불변 객체: DTO는 변경 불가능한(immutable) 객체로 설계하는 것이 좋습니다. 이를 통해 데이터의 무결성을 보장하고 동시성 문제를 방지할 수 있습니다.
직렬화 가능: DTO는 데이터를 전송하는 용도로 사용되므로 직렬화 가능하도록 구현되어야 합니다. 이를 위해 직렬화 인터페이스를 구현하거나 직렬화 라이브러리를 활용할 수 있습니다.
네이밍 규칙: DTO 클래스의 이름은 해당하는 비즈니스 도메인을 잘 반영하고, 필드명은 명확하고 의미있는 네이밍 규칙을 따라야 합니다.
스프링에서는 DTO를 사용하는 방식에 대해 강제하는 규칙은 없습니다. 개발자의 선호도와 프로젝트의 구조에 따라 DTO를 어떻게 사용할지 결정할 수 있습니다. 일반적으로는 필요한 데이터 전달과 뷰 모델로 사용되는 등의 상황에서 DTO를 적절히 활용하는 것이 바람직합니다.


####DTO와 Entity의 차이?

목적: DTO는 데이터를 전송하거나 전달하기 위한 객체로 사용됩니다. 주로 데이터 전송이나 뷰 모델로 사용됩니다. 반면에, 엔티티는 비즈니스 도메인의 개념을 나타내는 객체입니다. 엔티티는 데이터베이스와의 상호작용을 담당하고 비즈니스 로직을 포함할 수 있습니다.

데이터의 관점: DTO는 주로 데이터 전달을 위한 용도로 사용되므로, 데이터를 담는 용도로 설계됩니다. 데이터를 표현하기 위한 필드와 그에 따른 getter/setter 메서드를 가지고 있습니다. 엔티티는 데이터베이스와의 매핑을 위한 속성과 관계, 비즈니스 로직을 포함하고 있을 수 있습니다.
상태 관리: DTO는 주로 데이터 전송을 위한 용도로 사용되기 때문에, 일반적으로 변경 불가능한(immutable) 객체로 설계됩니다. 즉, 한 번 생성된 DTO는 변경되지 않는 것이 일반적입니다. 엔티티는 비즈니스 로직을 포함할 수 있고, 엔티티의 상태는 변경될 수 있습니다.
의존성 관리: DTO는 주로 프레젠테이션 계층과 서비스 계층 사이에서 데이터 전달을 위해 사용되므로, 의존성이 비교적 적습니다. 엔티티는 데이터베이스와의 상호작용을 담당하므로, 데이터베이스와의 의존성이 있을 수 있습니다.
매핑: DTO는 주로 데이터 전송을 위해 사용되기 때문에, 데이터베이스와의 직접적인 매핑은 필요하지 않습니다. 엔티티는 주로 데이터베이스와의 상호작용을 담당하므로, 데이터베이스와의 매핑을 위한 어노테이션 또는 매핑 설정이 필요합니다.
일반적으로 엔티티는 비즈니스 도메인에서 사용되는 객체이며, DTO는 데이터 전송을 위한 객체입니다. 엔티티는 데이터베이스와의 상호작용과 비즈니스 로직을 담당하고, DTO는 데이터 전달 및 뷰 모델로 사용되는 경량화된 데이터 객체입니다.


####커넥션 풀 생성 개수를 결정하는 기준들?

동시 사용자 수: 애플리케이션의 동시 사용자 수는 커넥션 풀의 크기에 직접적인 영향을 줍니다. 동시 사용자 수가 많을수록 커넥션 풀의 크기도 그에 맞게 조정되어야 합니다. 예를 들어, 수백 개 이상의 동시 사용자를 처리하는 대규모 애플리케이션은 더 큰 커넥션 풀이 필요할 수 있습니다.
데이터베이스 서버의 용량: 커넥션 풀의 크기는 백엔드 데이터베이스 서버의 용량과 성능에 맞춰야 합니다. 데이터베이스 서버가 동시에 처리할 수 있는 최대 커넥션 수를 고려하여 커넥션 풀의 크기를 설정해야 합니다.
응답 시간 요구 사항: 애플리케이션의 응답 시간 요구 사항에 따라 커넥션 풀의 크기를 조정해야 합니다. 응답 시간이 빠른 풀 크기를 유지하기 위해 충분한 수의 커넥션이 필요합니다. 응답 시간이 중요한 애플리케이션에서는 추가적인 리소스를 투입하여 커넥션 풀의 크기를 증가시키는 것이 바람직합니다.
애플리케이션의 확장성: 애플리케이션의 확장성 요구 사항에 따라 커넥션 풀의 크기를 조정해야 합니다. 예를 들어, 애플리케이션의 수평 확장이 필요한 경우, 더 큰 커넥션 풀을 사용하여 추가적인 인스턴스에서 동시에 처리할 수 있는 커넥션 수를 늘릴 수 있습니다.

####form-data 형식이란?

form-data는 웹 애플리케이션에서 데이터를 전송하는 방식 중 하나입니다. 이 형식은 주로 파일 업로드나 폼 데이터 전송에 사용됩니다. form-data 형식은 multipart/form-data MIME 타입으로 표시되며, HTTP 요청 본문의 일부 또는 전체를 포함하는 데이터 블록으로 이루어집니다.

form-data 형식은 일반적으로 다음과 같은 상황에서 사용됩니다:
파일 업로드: 웹 페이지나 애플리케이션에서 사용자가 파일을 선택하여 서버로 업로드할 때 사용됩니다.
폼 데이터 전송: 웹 폼에서 입력한 데이터를 서버로 전송할 때 사용됩니다. 예를 들어, 사용자가 이름, 이메일 주소, 나이 등을 입력하는 폼 데이터를 서버로 전송할 때 form-data 형식을 사용할 수 있습니다.
form-data 형식은 멀티파트 요청으로 데이터를 전송합니다. 각 필드는 이름-값 쌍으로 구성되며, 파일 업로드의 경우 파일 데이터도 포함됩니다. 각 필드는 고유한 Content-Disposition 헤더와 함께 전송됩니다. 이 헤더는 필드의 이름과 파일 이름(선택적)을 지정합니다.

form-data 형식은 주로 HTML <form> 요소를 사용하여 웹 페이지에서 사용됩니다. 그러나 API 개발 도구나 HTTP 클라이언트를 사용하여도 form-data 요청을 생성할 수 있습니다.

####dao, dto, vo, entity 차이

DAO(Data Access Object) 란?
repository package
실제로 DB에 접근하는 객체이다.
Persistence Layer(DB에 data를 CRUD하는 계층)이다.
Service와 DB를 연결하는 고리의 역할을 한다.
SQL를 사용(개발자가 직접 코딩)하여 DB에 접근한 후 적절한 CRUD API를 제공한다.
JPA 대부분의 기본적인 CRUD method를 제공하고 있다.
extends JpaRepository<User, Long>

DTO(Data Transfer Object) 란?
dto package
계층간 데이터 교환을 위한 객체(Java Beans)이다.
DB에서 데이터를 얻어 Service나 Controller 등으터 보낼 때 사용하는 객체를 말한다.
즉, DB의 데이터가 Presentation Logic Tier로 넘어오게 될 때는 DTO의 모습으로 바껴서 오고가는 것이다.
로직을 갖고 있지 않는 순수한 데이터 객체이며, getter/setter 메서드만을 갖는다.
하지만 DB에서 꺼낸 값을 임의로 변경할 필요가 없기 때문에 DTO클래스에는 setter가 없다. (대신 생성자에서 값을 할당한다.)
Request와 Response용 DTO는 View를 위한 클래스
자주 변경이 필요한 클래스
Presentation Model
toEntity() 메서드를 통해서 DTO에서 필요한 부분을 이용하여 Entity로 만든다.
또한 Controller Layer에서 Response DTO 형태로 Client에 전달한다.

참고 VO(Value Object) vs DTO
VO는 DTO와 동일한 개념이지만 read only 속성을 갖는다.
VO는 특정한 비즈니스 값을 담는 객체이고, DTO는 Layer간의 통신 용도로 오고가는 객체를 말한다.

VO(Value Object) 란?
VO(Value Object)는 말 그대로 값 객체라는 의미를 가지고 있다.
VO의 핵심 역할은 equals()와 hashcode()를 오버라이딩 하는 것이다.
VO 내부에 선언된 속성(Field)의 모든 값들이 VO 객체마다 값이 같아야, 똑같은 객체라고 판별한다.

Entity Class 란?
domain package
실제 DB의 테이블과 매칭될 클래스
즉, 테이블과 링크될 클래스임을 나타낸다.
Entity 클래스 또는 가장 Core한 클래스라고 부른다.
@Entity, @Column, @Id 등을 이용
최대한 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서 필요한 로직 method을 구현한다.
단, Domain Logic만 가지고 있어야 하고 Presentation Logic을 가지고 있어서는 안된다.
여기서 구현한 method는 주로 Service Layer에서 사용한다.

-참고 Entity 클래스와 DTO 클래스를 분리하는 이유
View Layer와 DB Layer의 역할을 철저하게 분리하기 위해서
테이블과 매핑되는 Entity 클래스가 변경되면 여러 클래스에 영향을 끼치게 되는 반면 View와 통신하는 DTO 클래스(Request / Response 클래스)는 자주 변경되므로 분리해야 한다.
Domain Model을 아무리 잘 설계했다고 해도 각 View 내에서 Domain Model의 getter만을 이용해서 원하는 정보를 표시하기가 어려운 경우가 종종 있다. 이런 경우 Domain Model 내에 Presentation을 위한 필드나 로직을 추가하게 되는데, 이러한 방식이 모델링의 순수성을 깨고 Domain Model 객체를 망가뜨리게 된다.
또한 Domain Model을 복잡하게 조합한 형태의 Presentation 요구사항들이 있기 때문에 Domain Model을 직접 사용하는 것은 어렵다.
즉 DTO는 Domain Model을 복사한 형태로, 다양한 Presentation Logic을 추가한 정도로 사용하며 Domain Model 객체는 Persistent만을 위해서 사용한다.

####Repository의 매개변수는 항상 Entity로만 정의해야하는지, 아니면 임의로 다른필드의 매개변수를 사용해도 되는지?